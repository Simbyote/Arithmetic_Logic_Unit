# ALU — Course Edition (CS 3398)
A parameterized Verilog implementation of an arithmetic logic unit with clean 
controller/core splits, modular n-bit gates, and testbenches

---
## Common Terminology
- **Combinational:** Logic is done at the same time
- **Sequential:** Logic is done at different times

- **Definition of Drone:** A minimum benchmark for a task to be considered complete
- **Oracles:** Determine whether a test has passed or failed

---
## How Does the ALU relate to Software Engineering?
In accordance with the principles of Software Engineering and the shared vision of
the course, the ALU presented works as a real-world example of how students would be
asked to develop and enhance ideas from already-existing codebases. Hence, by introducing
the idea of an ALU, we as a group are able to focus more on the design principles of
Software Engineering than the actual implementation of the ALU.

---

## 1. What is included (Baseline)
- **Gates & Builders:** Bit and n-bit logic gates, instantiated via a *Gate_Instantiator* module
- **Arithmetic Cores:** Add/sub, shift (logical & arithmetic), comparators, mul (shift-add), div (iterative checks)
- **ALUs:**: 'combinational_alu' (core operations) and 'sequential_alu' (FSM controller) featuring latched outputs for signal stability
- **Testbenches & Makefile:** Specialized testbenches for gates/shift/ALU logic verification, writing results to VCD files
- **Reports (LaTeX):** Documentation reports explaining the development process, design choices, and waveforms generated by the testbenches

## 2. Course enhancement (Waterfall)
**Goal:** Add clear, end-to-end *signed integer semantics* and small *status registers*, then verify rigorously

- **Scope (Essentials):**
    - Implement and expose flags **Z/N/C/V** (zero/negative/carry/overflow)
    - Define **signed add/sub** rules  (overflow v. carry) and **signed comparators** where required
    - Harden shifter edge cases (clamp `shift_amt` to `[0..WIDTH-1]`; define `shift_amt==0` as no-op)
    - Update testbenches to be **self-checking** and traceable to requirements

- **Niceties (Extras):**
    - Behavioral ALU module for oracles in testbenches
    - Optional **cocoTB** Python tests alongside HDL testbenches
    - Rotate-L/R ops behind shifters

- **Out of Scope (Challenges):**
    - Full IEEE-754 semantics for floating point; multi-precision arithmetic

## 3. Flags & Semantics (Contract)
- `Z` set iff results == 0
- `N` mirrors result MSB
- `C` add = carry out of MSB; sub = borrow ("not-borrow": Arm-style semantics)
- 'V' two's-complement overflow

## 4. Repo Layout (Structure)
| Directory | Description                                       | 
|:----------|:------------                                      |
| `/docs`   | LaTeX reports                                     |   
| `/out`    | VCD waveforms                                     |
| `/src`    | gates, arithmetic cores, ALUs, flags module (new) |
| `/tb`     | HDL testbenches, optional cocoTB testbenches      |

## 5. Build & Run (Compilation)
> Requires `iverilog`, `vvp`, and `gtkwave` (optional `python`) 

```bash
# HDL flow
make        # compile all benches
make clean  # remove builds and output/*

# Test produced VCD file:
gtkwave out/wave/waveform1.vcd

# Optional: 
#   - Add cocoTB flow?
#   - Add single target to makefile? 
```

## 6. Testing and Traceability (Verification)
- **Unit Tests:** Per-module testbenches for gates, arithmetic cores, and ALUs
- **Integration Tests:** Opcode-driven ALU sequences; `DONE` handshaked and latched outputs verified
- **Oracles:** Behavioral ALU in Verilog or Python (cocoTB) model
- **Edge Cases:** Carry without overflow; overflow without carry; min/max values
- **Traceability:** `docs/test_plan.md` maps each test ID → requirement ID

## 7. Waterfall Artifacts (Traceability)
- **SRS (`docs/srs.md`):** Numeric ranges, signedness, opcode list, flag rules, reset/clock assumptions, and acceptance criteria
- **Architecture Description (`docs/arch.md):** Stakeholders, concerns, and views; where flags are computed/latching occurs
- **Test Plan (`docs/test_plan.md`):** Objectives, test design, data, environment, pass/fail oracles, coverage notes
- **Presentation (`docs/slides/`):** Short deck for in-class demo

## 8. Contributions (Collaboration)
- **Roles:** *Requirements* (SRS lead), *Architecture* (design/flags integration), *Arithmetic* (signed add/sub & comparators), *Shifters/Edges* (clamp/rotate), *Verification* (benches/oracles/coverage)
- **Workflow:** Short issues per task; small PRs with waveforms/screens as evidence; every PR links tests to requirement IDs
- **Definition of Drone:** Code compiles, benches pass, and documentation updated (SRS/Arch/Test Plan)

## 9. Roadmap (Planning)
- [ ] Add `flags.v` (computes Z/N/C/V) and wire into ALU top
- [ ] Replace single overloaded `flag` with `status[3:0]` register
- [ ] Signed compares (`%signed(a) < $signed(b)`) where applicable
- [ ] Shifter hardening & rotate ops (optional)
- [ ] Self-checking benches & minimal golden model (HDL or Python)
- [ ] Traceability matrix & CI-friendly make targets

# 10. Licenses
This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details

## Getting Started (Setup)
1. Clone repo
2. Install dependencies (`iverilog`, `vvp`, `gtkwave`, `python`)
    ('vvp' can be installed via sudo add-apt-repository ppa:team-electronics/ppa)
3. Run `make` to compile and run all testbenches

## External Resources That Helped Me (References)
> [BuildElectronicCircuit](https://www.build-electronic-circuits.com/)
- Have excellent resources for learning electronics and circuit design

> [ChipVerify](https://www.chipverify.com/tutorials/verilog)
- Great resource for learning Verilog if you're new to the language