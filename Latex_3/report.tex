\documentclass[12pt]{article}

\usepackage{fancyhdr}   
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{graphicx}    % include graphics
\usepackage{natbib}         
\usepackage{doi}    
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz-timing}    % timing diagrams
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\setcitestyle{aysep={,}}

% Header information
\newcommand{\Group}{Group Uno}
\newcommand{\Mike}{Mike Orduna}
\newcommand{\Noah}{Noah Murphy}
\newcommand{\Alex}{Alex Livingston}
\newcommand{\Class}{CS 3339: Computer Architecture}
\newcommand{\ReportPart}{Part Three}
\newcommand{\School}{Ingram School of Engineering}

\title{Project Report: \ReportPart}
\author{
    \textbf{\Class} \\
    \\
    \textbf{\Group:} 
    \\
    \Mike\\
    \Noah\\
    \Alex\\
    \\
    \\
    \School
}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\hypersetup{hidelinks}  % remove colored boxes around links

\begin{document}
\maketitle
\newpage

\tableofcontents
\thispagestyle{empty}
\pagestyle{fancy}

\newpage
\setcounter{page}{1}

\section{Abstract}

\section{Background}
This report is the third part of a project that aims to develop an ALU using Verilog. The ALU could not be as functional as it is currently without
the previous implementations of the ALU's most basic modules. Throughout the course of the project, design decisions were made to ensure that the ALU
remained modular and easy to understand. That being said, the ALU was chosen to follow a \textit{hierarchical design} approach, where the ALU is built
from smaller modules.

Development of the ALU began with implementing its most basic functions: \textit{Logic Gates}. Implementation starts with making modules for these basic
gates, which are then used to develop more complex modules down the line. In the first report discussed, the primary focus was ensuring that these logic
gates received the fed inputs correctly and produced the expected outputs. Furthermore, the development of a basic arithmetic shifter was implemented in
conjunction with the logic gates, as required by the project's first step. These files can be viewed under the \textbf{src} directory, and more specifically
refer to the files \textit{bit\_gates.v}, \textit{nbit\_gates.v}, and \textit{arithmetic\_operations.v}. Other modules made in this section include the
\textit{checks.v} and the \textit{mxnbit\_gates.v} files which offer additional functionality outside of the specifications of the project.

Afterwards, the development of the core functions of the ALU were implemented. This included the basic mathematical operations of an ALU: addition,
subtraction, multiplication, and division. Following the guidelines developed during the planning of the project, this section of the ALU is built on
many of the logic gates previously developed and make use of Verilog's \textit{generate} statements to instantiate the appropriate modules for each
operation. The modules refer to the files \textit{arithmetic\_operations.v} and the later added \textit{combinational\_alu.v} files. In earlier versions
of this part of the project, the operations for the ALU went through many different iterations and were all shared in the same file. However, after 
much evaluation, a separation of concerns was established and enforced between the two core functions, leading to the split of the files.

While the initial project phases emphasized the development of the ALU's core functions, the later phases of the project focus on the refinement of
the ALU's modules. Moreover, the later phases of the project focus on the introduction of a controller to the ALU, allowing for it to perform its
calculations more realistically and sequentially.

\section{Introduction}
An ALU's effectiveness is not only determined by its ability to perform arithmetic operations, but also by its ability to manage the flow of these
operations over a period of time. In earlier stages of the project, the ALU's primary focus was functionality and correctness of the operations. However,
moving from the core functions of the ALU to the controller, the focus shifts to the overall control the ALU has over its operations.

The introduction of control logic to the ALU transforms it from a purely combinational circuit into one that is sequential. This means that the ALU
would process instructions fed into it over multiple clock cycles. This change in fundamental processing allows for an ALU to synchronize its operations,
managing its time and resources more effectively. In this report, a focus on the developmental process of the ALU controller is discussed, including the
methods used to implement the controller, the challenges faced during development, and the solutions that were developed to overcome these challenges.

\section{Controller Design}
The controller is the most important aspect of an ALU, as it is responsible for directing the flow of data and operations within the ALU. A controller
is a sequential circuit that takes in inputs and produces outputs based on the current state of the system. 

\subsection{Controller Inputs and Outputs}
To design the controller, defining its inputs and outputs is essential. There are two types of inputs to a controller: the timing inputs and the ALU inputs.
The timing inputs are the signals that are used to control the timing of the controller's operations and include the following:
\begin{itemize}
    \item \textbf{Clock}: The clock signal is used to synchronize the operations of the ALU. It is a periodic signal that is used to trigger the controller's state transitions.
    \item \textbf{Reset}: The reset signal is used to initialize the controller to a known state. It is an active high signal that resets the controller's state.
    \item \textbf{Start}: The start signal is used to indicate that the ALU should begin processing an operation. It is an active high signal that triggers the controller to start its operation.
\end{itemize}

The ALU inputs are the signals that are used to determine and perform the operation to be performed by the ALU. These inputs include the following:
\begin{itemize}
    \item \textbf{Opcode}: The opcode is a binary representation of the operation to be performed by the ALU. It is a multi-bit signal that is used to select the operation to be performed.
    \item \textbf{Input 1}: The first input to the ALU. It is a multi-bit signal that is used as the first operand for the operation.
    \item \textbf{Input 2}: The second input to the ALU. It is a multi-bit signal that is used as the second operand for the operation.
\end{itemize}

The primary output is split into three outputs: a high, a low, and a flag. This is to accommodate the different methods of outputting from the individual ALU operations.
The outputs are as follows:
\begin{itemize}
    \item \textbf{High Output}: The high output is a multi-bit signal that is used to indicate the high portion of outputs. Primarily used in multiplication, division, or shift operations.
    \item \textbf{Low Output}: The low output is a multi-bit signal that is used to indicate the low portion of outputs. This is used to represent the remaining operations such as addition or subtraction
        as well as the low portion of multiplication and division or the shift result.
    \item \textbf{Flag}: The flag is a single bit signal that is used to represent carry, borrow, or comparison flags.
\end{itemize}

The controller has an output to mark its completion labeled as \textit{done}. This is a single bit signal that is used to indicate that the ALU has completed its operation and is ready to output
the result.

\subsection{Separation of Concerns}
In order to facilitate the development of the controller, a separation was established between the main ALU controller and the sub-controllers. 
\begin{itemize}
    \item \textbf{Sequential Controller}: Acts as the main controller for the ALU. It is responsible for managing the overall flow of the ALU operations and directing the sub-controllers to perform their respective operations.
    \item \textbf{Sub-Controllers}: These are the individual controllers that are responsible for performing the specific operations of the ALU. Each sub-controller is responsible for a specific operation, such as addition, 
        subtraction, multiplication, or division.
\end{itemize}

\subsection{When to Use a Controller?}
In the design of the ALU's controller, it was important to ask when to develop a controller for a specific module. Not every operation in an ALU requires a controller, as in some cases operations
are done in one clock cycle as opposed to a span of cycles. Since the combinational logic was split in its core operations, it was deduced that those operations, operations with a \textit{core} unit 
attached to them would need to be controlled by some central controller. This meant that modules such as the shifter, the comparator, and the logic gates would not need a controller, while remaining
modules would.

Furthermore, since the ALU controller was split into two function, it would not be ideal for both the ALU controller and the sub-controllers to be sequential. Had both controllers included sequential logic, 
the interaction between their clock cycles would create more complicated timing mismatches, which in turn would require more complex logic to manage. So it was declared that the ALU controller would solely 
be combinational, while still housing the timing inputs to feed into the sub-controllers; those of which did function on the timing inputs. This design decision allowed for the separation of concerns between 
the different controllers developed for the ALU and allowed for a more modular design.

\section{Testbench Development}
To test the functionality of the controllers developed, two generic tests were designed and made, similarly to how they were discussed in the previous report, \textit{Part Two}. These tests iterated through
every potential input combination possible for the ALU. More specifically, it incremented the 3 primary inputs in the ALU: the opcode, input 1, and input 2. 

\subsection{Testbench Design}
The tests also needed to include some method of tracking the clock and reset signals so that the ALU could be properly initialized and run for each change in input. In order to properly capture the correct 
change in output for each change in input, posedge detections were added into the generic tests. These posedges are used to tell the controller to update its state and output registers. However, applying a
posedge requires a careful consideration for where they are placed in the generic tests to avoid saturating the system with too many posedges and thatv it updates its outputs accordingly. The general rules
to follow when adding posedges are:
\begin{itemize}
    \item \textbf{Posedge Between Input Change}: This is to ensure that the controller updates its state and output registers before the next input change.
    \item \textbf{Posedge Between Control Transitions}: This is to ensure that the controller updates its state and output registers before the next control transition.
    \item \textbf{Posedge After Setting Done Signals}: This is to ensure that the controller updates its state and output registers after the done signal is set.
\end{itemize}

\subsection{Testbench Implementation}
The testbench was implemented in a separate file, \textit{testbench\_sequential.v}. This file tested two both the ALU controller and the sub-controllers.

\subsubsection{Sub-Controller Testing}
Testing was first done on the sub-controllers, as they
relied on their \textit{core} units. Developing these controllers first allowed for a more modular design to be implemented across the different sub-controllers, as we would be testing for similar functionality
across the different modules. The testbench developed for the sub-controllers is shown below:
\begin{lstlisting}[language=Verilog]
    `define GENERIC_CONTROL( REG1, REG2, CLK, RESET, START, DONE ) \
    begin \
        RESET = 1'b0; START = 1'b0; \
        REG1 = { WIDTH{ 1'b0 } }; \
        repeat( BIT_STATE ) begin \
            REG2 = { WIDTH{ 1'b0 } }; \
            repeat( BIT_STATE ) begin \
                RESET = 1'b1; @( posedge CLK ); \
                RESET = 1'b0; @( posedge CLK ); \
                @( posedge CLK ); \
                START = 1'b1; @( posedge CLK ); \
                START = 1'b0; \
                wait( DONE ); \
                @( posedge CLK ); @( posedge CLK ); \
                REG2 = REG2 + 1; @( posedge CLK ); \
            end \
            REG1 = REG1 + 1; @( posedge CLK ); \
        end \
        REG1 = {WIDTH{1'b0}}; \
        REG2 = {WIDTH{1'b0}}; \
    end
\end{lstlisting}

The test was implemented using a macro to allow for a generic test to be used with any of the different controllers. The macro takes in the following parameters:
\begin{itemize}
    \item \textbf{REG1}: The first register to be tested. This is the register that will be used to store the first input to the ALU.
    \item \textbf{REG2}: The second register to be tested. This is the register that will be used to store the second input to the ALU.
    \item \textbf{CLK}: The clock signal for the ALU. This is the signal that will be used to synchronize the operations of the ALU.
    \item \textbf{RESET}: The reset signal for the ALU. This is the signal that will be used to initialize the ALU to a known state.
    \item \textbf{START}: The start signal for the ALU. This is the signal that will be used to indicate that the ALU should begin processing an operation.
    \item \textbf{DONE}: The done signal for the ALU. This is the signal that will be used to indicate that the ALU has completed its operation and is ready to output the result.
\end{itemize}

Each timing input is carefully placed to ensure that the system is able to record and process the inputs correctly. One mismatch in the timing of the inputs could
lead to a loss of information, where old data is saved or data that does not exist yet is used. This is why the timing of the inputs is so important in the design of
the controller. 

\subsubsection{Clock Signal Implementation}
Notice that the clock signal is not included in the macro directly; there is no CLK that is incremented in the macro. Rather, the clock is initialzied outside of the macro, 
in the testbench. There are a few standard methods for which to increment a clock depending on the application. For the purpose of this testbench, a simple implementation
was used to increment the clock:
\begin{lstlisting}[language=Verilog]
    initial begin
        clk = 1'b0;
        # Inverts the clock every 5 time units
        forever #5 clk = ~clk;
    end
\end{lstlisting}

This implementation increments the clock signal every 5 time units, which is set to 1ns for the purpose of this testbench. This means that the clock signal will toggle every 5ns
forever, until the simulation is stopped. This is a simple implementation of a clock signal that is used to synchronize the operations of the ALU.

\subsubsection{ALU Controller Testing}
Testing for the ALU controller was done in a similar fashion to the sub-controllers, with the only difference being an extra input to the macro: the opcode. The opcode is placed
at the beginning of the macro, as it is the first input to be changed. The opcode is then incremented in a loop after the remaining test is concluded. For every opcode, the generic
test listed above is conducted.

\subsection{Testbench Timing Diagrams}
At the lowest level of the testbench, the clock, reset, and start signals make up a single input change. This change is represented by the timing diagram shown below.
\begin{figure}[H]
    \centering
    \begin{tikztimingtable}[timing/slope=0, xscale=1.2]
    CLK & 12{LH} \\
    RST & H 22L 1H \\
    START & 5L 2H 17L \\
    DONE & 18L 2H 4L \\
    \end{tikztimingtable}
    \caption{Timing diagram showing one ALU controller activation cycle with a reset phase, input start pulse, and synchronization to the system clock.}
\end{figure}

The diagram illustrates the signal timing associated with a single change in input. The \texttt{CLK} signal remains periodic with a constant cycle length. This is the
result of the code mentioned in the \textit{Clock Signal Implementation} section. The \texttt{RST} (reset) signal is asserted at the beginning to initialize the system and then
deasserted after the first rising edge. It remains low for most of the operation and is reasserted at the end to reset the state for the next operation. The \texttt{START} signal 
is asserted for two clock cycles after reset is deasserted, signaling the controller to begin executing the operation based on current inputs. The \texttt{DONE} signal is asserted 
for two clock cycles once the operation is complete, indicating the result is available and the controller is ready for the next input.

All control signals (\texttt{RST}, \texttt{START}, and \texttt{DONE}) are held high for \textit{two full clock cycles} rather than one to ensure the controller registers each transition
reliably. This design choice prevents race conditions and ensures that state changes are properly latched. The effect of this timing strategy will become more evident in later sections
when the behavior of the sub-controllers is analyzed.

\subsection{Testbench Module Instantiations}
In order to use the macro in the testbench, the modules to be tested need to be instantiated in the testbench. This is done by creating instances of the modules that are to be tested
and passed into the macro. One example of this is shown below, where the \textit{Addition\_Control} module is instantiated in the testbench:
\begin{lstlisting}[language=Verilog]
    /*
     * Addition_Control module instantiation
     */
    reg [ WIDTH-1:0 ] add_in1, add_in2;
    wire [ WIDTH-1:0 ] add_out;
    wire add_done, final_carry;

    Addition_Control #( .WIDTH( WIDTH ) ) add_control_instance (
        .clk( clk ),
        .reset( reset ),
        .start( start ),
        .in1( add_in1 ),
        .in2( add_in2 ),
        .out( add_out ),
        .final_carry( final_carry ),
        .done( add_done )
    );

    // Latch the output signals for clearer waveform
    reg [WIDTH-1:0] add_latched;
    reg carry_latched;
    always @(posedge clk) begin
        if( add_done ) begin
            add_latched <= add_out;
            carry_latched <= final_carry;
        end
    end
\end{lstlisting}

Every module tested is instantiated the same way, with differences being the naming of input variables and module names. 

\subsubsection{Latch Implementation}
It is important to note the use of a \textit{latch} for the output signals. The outputs from each module vary or oscillate with the periodic clock due to the internal combinational 
circuitry, which can produce intermediate values between clock edges. To avoid an oscillating output, the output signal can be latched using a flip-flop register. The latching is 
done using a simple always block that captures the output of the module when the \texttt{DONE} signal is asserted. This ensures a stable output value is captured until the next 
operation is completed.

\section{ALU Controller}
The ALU controller is the top-level controller for the ALU, as it designates the flow of data and operations within the ALU. The inputs and outputs of the ALU controller are discussed
in the \textit{Controller Inputs and Outputs} section.

\subsection{ALU Operations}
The ALU controller is a combinational circuit that is run using a finite state machine which helps it to organize and manage the different operations of the ALU. In order to maintain
the modularity and hierarchical design, the ALU instantiates the sub-controllers before entering its FSM. Because of this, every operation in the ALU is computed per input. However,
once the FSM is entered, only the specified operation is transferred and outputted by the ALU controller module.

\subsubsection{ALU Controller States}
The ALU controller is designed to handle the following operations with the assigned opcodes:
\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Operation} & \textbf{Opcode}    \\
        \hline
        \texttt{Addition} & 0000 \\
        \texttt{Subtraction} & 0001 \\
        \texttt{Multiplication} & 0010 \\
        \texttt{Division} & 0011 \\
        \texttt{Logical Shift} & 0100 \\
        \texttt{Arithmetic Shift} & 0101 \\
        \texttt{Greater Than} & 0110 \\
        \texttt{Less Than} & 0111 \\
        \texttt{Equal To} & 1000 \\
        \texttt{Bitwise AND} & 1001 \\
        \texttt{Bitwise OR} & 1010 \\
        \texttt{Bitwise XOR} & 1011 \\
        \texttt{Bitwise NOT} & 1100 \\
        \hline
    \end{tabular}
    \caption{ALU Opcode Table}
\end{figure}

One thing to note about the ALU operations is the difference between the logical and arithmetic shifts. \textit{Logical shifts} are used to shift the bits of a number to the left or
right, filling the empty bits with zeros. This is useful for unsigned numbers, where the sign of the number does not matter. \textit{Arithmetic shifts}, on the other hand, are used to shift
the bits of a signed number to the left or right, filling the empty bits with the sign bit. This is useful for signed numbers, where the sign of the number matters. While these options
are not explicitly used, they still provide a useful starting point if additional features wwere to be added to the ALU in the future.

\subsubsection{Sub-Controller Instantiations}
The ALU controller instantiates the sub-controllers for each operation to be performed. This is a feature of the ALU controller that allows for the modularity of the design to be maintained
more easily. This also allows for the ALU to pass down the responsibility of the operations to the sub-controllers, rather than having all the logic in the ALU controller. However, this does
impact the performance of the ALU, as the ALU controller must wait for the sub-controllers to complete their operations before it can proceed, even when the operation is not needed.

Each sub-controller is instantiated such like:
\begin{lstlisting}[language=Verilog]
    // Addition Controller
    wire [ WIDTH-1:0 ] add_out;
    wire add_done, final_carry;

    Addition_Control #( .WIDTH( WIDTH ) ) adder_instance (
        .clk( clk ),
        .reset( reset ),
        .start( start ),
        .in1( in1 ),
        .in2( in2 ),
        .out( add_out ),
        .final_carry( final_carry ),
        .done( add_done )
    );
\end{lstlisting}

Most of the sub-controllers are instantiated in a similar fashion, with the differences being the naming conventions and the output signals. The instantiations allow for a modular and cleaner design, 
as the ALU controller becomes a simple wrapper around the sub-controllers. This allows for the ALU controller to be easily modified or extended in the future, as new operations can be added by simply
adding a new sub-controller and updating the ALU controller to include the new operation. This is a key feature of the hierarchical design approach taken in this project.

\subsubsection{ALU Finite State Machine}
The finite state machine for the ALU controller is designed to be purely combinational. It selects and coordinates which of the sub-controllers outputs to use based on the opcode. The FSM for
the ALU was originally designed to be sequential, but due to timing mismatches between the ALU controller and the sub-controllers, it was changed to be purely combinational. This change
allows for easier debugging and readability at the cost of performance. The FSM is designed to be simple and easy to understand and is implemented using a case statement:
\begin{lstlisting}[language=Verilog]
    always @(*) begin
        // Initialize the output signals
        out_high = { WIDTH{ 1'b0 } };
        out_low = { WIDTH{ 1'b0 } };
        flag = 1'b0;
        done = 1'b0;

        case( opcode )
            ADD: begin
                out_low = add_out;
                flag = final_carry;
                done = add_done;
            end
            SUB: begin
                out_low = sub_out;
                flag = final_borrow;
                done = sub_done;
            end
            ... and so on
\end{lstlisting}

This pattern continues for all available operations, where the different outputs are assigned based on which operation is selected. Not every output in the ALU controller is assigned due to
either a limited representation of the output or the lack of need for the output. Due to how the operations performed have varying output sizes, the outputs from the ALU remain flexible.

\section{Sub-Controllers}
\subsection{General Sub-Controller Operation}

\subsection{Adder Controller}
\subsubsection{Adder Controller States}
\subsubsection{Adder Instantiations}
\subsubsection{Adder FSM}

\subsection{Subtractor Controller}
\subsubsection{Subtractor Controller States}
\subsubsection{Subtractor Instantiations}
\subsubsection{Subtractor FSM}

\subsection{Multiplier Controller}
\subsubsection{Multiplier Controller States}
\subsubsection{Multiplier Instantiations}
\subsubsection{Multiplier FSM}

\subsection{Divider Controller}
\subsubsection{Divider Controller States}
\subsubsection{Divider Instantiations}
\subsubsection{Divider FSM}

\subsection{Comparison Controllers}
\subsubsection{Comparison Controller States}
\subsubsection{Comparison Instantiations}
\subsubsection{Comparison FSM}

\section{Waveform Analysis}

\section{Challenges and Solutions}

\section{Conclusion}

\section{Thoughts and Notes}
\begin{itemize}
    \item \textbf{Missing Final Bit in Multiplier}: Refactoring of the current Multiplier was necessary so that it can run sequentially rather than all at once.
        However, a few bugs were encountered while trying to implement this new feature. The main issue with the final product was that the control logic was 
        performing what seemed like \textit{one extra step} in the multiplication step. More specifically, this extra step was found to be at every instance of
        in2 where its value was at its maximum. This caused an incorrect final output to be produced. What was found to be the source of the issue was that the
        FSM was \textit{conditionally updating the output registers} only when \textit{is\_equal} was true, otherwise it would skip the assignment. As a result,
        the final clock cycle would transition into the DONE state without properly updating the output registers for the final output. A resolution was developed
        that reshaped the logic in the \textit{STEP} and \textit{DONE} states, moving the final assignment out of DONE and into the STEP state while adding additional
        logic checks to ensure that the output registers were properly updated when they needed to be.
    \item \textbf{Timing Mismatch in Addition}: Refactoring the Adder Module was similarly done as the Multiplier Module. However, a bug was encountered where the output
        of the adder was shifted up the output register. This was found to be due to the timing of the output register assignment, where the output register was
        being assigned the value of the output of the adder before the adder had finished its operation. To resolve this issue, we split the function into two 
        different clock cycles, one for the addition and one for the assignment of the output register. This allowed the adder to finish its operation before the
        output register was assigned the value of the output of the adder.
\end{itemize}

\end{document}

