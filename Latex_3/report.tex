\documentclass[12pt]{article}

\usepackage{fancyhdr}   
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{graphicx}    % include graphics
\usepackage{natbib}         
\usepackage{doi}    
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz-timing}    % timing diagrams
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\setcitestyle{aysep={,}}

% Header information
\newcommand{\Group}{Group Uno}
\newcommand{\Mike}{Mike Orduna}
\newcommand{\Noah}{Noah Murphy}
\newcommand{\Alex}{Alex Livingston}
\newcommand{\Class}{CS 3339: Computer Architecture}
\newcommand{\ReportPart}{Part Three}
\newcommand{\School}{Ingram School of Engineering}

\title{Project Report: \ReportPart}
\author{
    \textbf{\Class} \\
    \\
    \textbf{\Group:} 
    \\
    \Mike\\
    \Noah\\
    \Alex\\
    \\
    \\
    \School
}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\hypersetup{hidelinks}  % remove colored boxes around links

\begin{document}
\maketitle
\newpage

\tableofcontents
\thispagestyle{empty}
\pagestyle{fancy}

\newpage
\setcounter{page}{1}

\section{Abstract}

\section{Background}
This report is the third part of a project that aims to develop an ALU using Verilog. The ALU could not be as functional as it is currently without
the previous implementations of the ALU's most basic modules. Throughout the course of the project, design decisions were made to ensure that the ALU
remained modular and easy to understand. That being said, the ALU was chosen to follow a \textit{hierarchical design} approach, where the ALU is built
from smaller modules.

Development of the ALU began with implementing its most basic functions: \textit{Logic Gates}. Implementation starts with making modules for these basic
gates, which are then used to develop more complex modules down the line. In the first report discussed, the primary focus was ensuring that these logic
gates received the fed inputs correctly and produced the expected outputs. Furthermore, the development of a basic arithmetic shifter was implemented in
conjunction with the logic gates, as required by the project's first step. These files can be viewed under the \textbf{src} directory, and more specifically
refer to the files \textit{bit\_gates.v}, \textit{nbit\_gates.v}, and \textit{arithmetic\_operations.v}. Other modules made in this section include the
\textit{checks.v} and the \textit{mxnbit\_gates.v} files which offer additional functionality outside of the specifications of the project.

Afterwards, the development of the core functions of the ALU were implemented. This included the basic mathematical operations of an ALU: addition,
subtraction, multiplication, and division. Following the guidelines developed during the planning of the project, this section of the ALU is built on
many of the logic gates previously developed and make use of Verilog's \textit{generate} statements to instantiate the appropriate modules for each
operation. The modules refer to the files \textit{arithmetic\_operations.v} and the later added \textit{combinational\_alu.v} files. In earlier versions
of this part of the project, the operations for the ALU went through many different iterations and were all shared in the same file. However, after 
much evaluation, a separation of concerns was established and enforced between the two core functions, leading to the split of the files.

While the initial project phases emphasized the development of the ALU's core functions, the later phases of the project focus on the refinement of
the ALU's modules. Moreover, the later phases of the project focus on the introduction of a controller to the ALU, allowing for it to perform its
calculations more realistically and sequentially.

\section{Introduction}
An ALU's effectiveness is not only determined by its ability to perform arithmetic operations, but also by its ability to manage the flow of these
operations over a period of time. In earlier stages of the project, the ALU's primary focus was functionality and correctness of the operations. However,
moving from the core functions of the ALU to the controller, the focus shifts to the overall control the ALU has over its operations.

The introduction of control logic to the ALU transforms it from a purely combinational circuit into one that is sequential. This means that the ALU
would process instructions fed into it over multiple clock cycles. This change in fundamental processing allows for an ALU to synchronize its operations,
managing its time and resources more effectively. In this report, a focus on the developmental process of the ALU controller is discussed, including the
methods used to implement the controller, the challenges faced during development, and the solutions that were developed to overcome these challenges.

\section{Controller Design}
The controller is the most important aspect of an ALU, as it is responsible for directing the flow of data and operations within the ALU. A controller
is a sequential circuit that takes in inputs and produces outputs based on the current state of the system. 

\subsection{Controller Inputs and Outputs}
To design the controller, defining its inputs and outputs is essential. There are two types of inputs to a controller: the timing inputs and the ALU inputs.
The timing inputs are the signals that are used to control the timing of the controller's operations and include the following:
\begin{itemize}
    \item \textbf{Clock}: The clock signal is used to synchronize the operations of the ALU. It is a periodic signal that is used to trigger the controller's state transitions.
    \item \textbf{Reset}: The reset signal is used to initialize the controller to a known state. It is an active high signal that resets the controller's state.
    \item \textbf{Start}: The start signal is used to indicate that the ALU should begin processing an operation. It is an active high signal that triggers the controller to start its operation.
\end{itemize}

The ALU inputs are the signals that are used to determine and perform the operation to be performed by the ALU. These inputs include the following:
\begin{itemize}
    \item \textbf{Opcode}: The opcode is a binary representation of the operation to be performed by the ALU. It is a multi-bit signal that is used to select the operation to be performed.
    \item \textbf{Input 1}: The first input to the ALU. It is a multi-bit signal that is used as the first operand for the operation.
    \item \textbf{Input 2}: The second input to the ALU. It is a multi-bit signal that is used as the second operand for the operation.
\end{itemize}

The primary output is split into three outputs: a high, a low, and a flag. This is to accommodate the different methods of outputting from the individual ALU operations.
The outputs are as follows:
\begin{itemize}
    \item \textbf{High Output}: The high output is a multi-bit signal that is used to indicate the high portion of outputs. Primarily used in multiplication, division, or shift operations.
    \item \textbf{Low Output}: The low output is a multi-bit signal that is used to indicate the low portion of outputs. This is used to represent the remaining operations such as addition or subtraction
        as well as the low portion of multiplication and division or the shift result.
    \item \textbf{Flag}: The flag is a single bit signal that is used to represent carry, borrow, or comparison flags.
\end{itemize}

The controller has an output to mark its completion labeled as \textit{done}. This is a single bit signal that is used to indicate that the ALU has completed its operation and is ready to output
the result.

\subsection{Separation of Concerns}
In order to facilitate the development of the controller, a separation was established between the main ALU controller and the sub-controllers. 
\begin{itemize}
    \item \textbf{Sequential Controller}: Acts as the main controller for the ALU. It is responsible for managing the overall flow of the ALU operations and directing the sub-controllers to perform their respective operations.
    \item \textbf{Sub-Controllers}: These are the individual controllers that are responsible for performing the specific operations of the ALU. Each sub-controller is responsible for a specific operation, such as addition, 
        subtraction, multiplication, or division.
\end{itemize}

\subsection{When to Use a Controller?}
In the design of the ALU's controller, it was important to ask when to develop a controller for a specific module. Not every operation in an ALU requires a controller, as in some cases operations
are done in one clock cycle as opposed to a span of cycles. Since the combinational logic was split in its core operations, it was deduced that those operations, operations with a \textit{core} unit 
attached to them would need to be controlled by some central controller. This meant that modules such as the shifter, the comparator, and the logic gates would not need a controller, while remaining
modules would.

Furthermore, since the ALU controller was split into two function, it would not be ideal for both the ALU controller and the sub-controllers to be sequential. Had both controllers included sequential logic, 
the interaction between their clock cycles would create more complicated timing mismatches, which in turn would require more complex logic to manage. So it was declared that the ALU controller would solely 
be combinational, while still housing the timing inputs to feed into the sub-controllers; those of which did function on the timing inputs. This design decision allowed for the separation of concerns between 
the different controllers developed for the ALU and allowed for a more modular design.

\section{Testbench Development}
To test the functionality of the controllers developed, two generic tests were designed and made, similarly to how they were discussed in the previous report, \textit{Part Two}. These tests iterated through
every potential input combination possible for the ALU. More specifically, it incremented the 3 primary inputs in the ALU: the opcode, input 1, and input 2. 

\subsection{Testbench Design}
The tests also needed to include some method of tracking the clock and reset signals so that the ALU could be properly initialized and run for each change in input. In order to properly capture the correct 
change in output for each change in input, posedge detections were added into the generic tests. These posedges are used to tell the controller to update its state and output registers. However, applying a
posedge requires a careful consideration for where they are placed in the generic tests to avoid saturating the system with too many posedges and thatv it updates its outputs accordingly. The general rules
to follow when adding posedges are:
\begin{itemize}
    \item \textbf{Posedge Between Input Change}: This is to ensure that the controller updates its state and output registers before the next input change.
    \item \textbf{Posedge Between Control Transitions}: This is to ensure that the controller updates its state and output registers before the next control transition.
    \item \textbf{Posedge After Setting Done Signals}: This is to ensure that the controller updates its state and output registers after the done signal is set.
\end{itemize}

\subsection{Testbench Implementation}
The testbench was implemented in a separate file, \textit{testbench\_sequential.v}. This file tested two both the ALU controller and the sub-controllers.

\subsubsection{Sub-Controller Testing}
Testing was first done on the sub-controllers, as they
relied on their \textit{core} units. Developing these controllers first allowed for a more modular design to be implemented across the different sub-controllers, as we would be testing for similar functionality
across the different modules. The testbench developed for the sub-controllers is shown below:
\begin{lstlisting}[language=Verilog]
    `define GENERIC_CONTROL( REG1, REG2, CLK, RESET, START, DONE ) \
    begin \
        RESET = 1'b0; START = 1'b0; \
        REG1 = { WIDTH{ 1'b0 } }; \
        repeat( BIT_STATE ) begin \
            REG2 = { WIDTH{ 1'b0 } }; \
            repeat( BIT_STATE ) begin \
                RESET = 1'b1; @( posedge CLK ); \
                RESET = 1'b0; @( posedge CLK ); \
                @( posedge CLK ); \
                START = 1'b1; @( posedge CLK ); \
                START = 1'b0; \
                wait( DONE ); \
                @( posedge CLK ); @( posedge CLK ); \
                REG2 = REG2 + 1; @( posedge CLK ); \
            end \
            REG1 = REG1 + 1; @( posedge CLK ); \
        end \
        REG1 = {WIDTH{1'b0}}; \
        REG2 = {WIDTH{1'b0}}; \
    end
\end{lstlisting}

The test was implemented using a macro to allow for a generic test to be used with any of the different controllers. The macro takes in the following parameters:
\begin{itemize}
    \item \textbf{REG1}: The first register to be tested. This is the register that will be used to store the first input to the ALU.
    \item \textbf{REG2}: The second register to be tested. This is the register that will be used to store the second input to the ALU.
    \item \textbf{CLK}: The clock signal for the ALU. This is the signal that will be used to synchronize the operations of the ALU.
    \item \textbf{RESET}: The reset signal for the ALU. This is the signal that will be used to initialize the ALU to a known state.
    \item \textbf{START}: The start signal for the ALU. This is the signal that will be used to indicate that the ALU should begin processing an operation.
    \item \textbf{DONE}: The done signal for the ALU. This is the signal that will be used to indicate that the ALU has completed its operation and is ready to output the result.
\end{itemize}

Each timing input is carefully placed to ensure that the system is able to record and process the inputs correctly. One mismatch in the timing of the inputs could
lead to a loss of information, where old data is saved or data that does not exist yet is used. This is why the timing of the inputs is so important in the design of
the controller. 

\subsubsection{Clock Signal Implementation}
Notice that the clock signal is not included in the macro directly; there is no CLK that is incremented in the macro. Rather, the clock is initialzied outside of the macro, 
in the testbench. There are a few standard methods for which to increment a clock depending on the application. For the purpose of this testbench, a simple implementation
was used to increment the clock:
\begin{lstlisting}[language=Verilog]
    initial begin
        clk = 1'b0;
        # Inverts the clock every 5 time units
        forever #5 clk = ~clk;
    end
\end{lstlisting}

This implementation increments the clock signal every 5 time units, which is set to 1ns for the purpose of this testbench. This means that the clock signal will toggle every 5ns
forever, until the simulation is stopped. This is a simple implementation of a clock signal that is used to synchronize the operations of the ALU.

\subsubsection{ALU Controller Testing}
Testing for the ALU controller was done in a similar fashion to the sub-controllers, with the only difference being an extra input to the macro: the opcode. The opcode is placed
at the beginning of the macro, as it is the first input to be changed. The opcode is then incremented in a loop after the remaining test is concluded. For every opcode, the generic
test listed above is conducted.

\subsection{Testbench Timing Diagrams}
At the lowest level of the testbench, the clock, reset, and start signals make up a single input change. This change is represented by the timing diagram shown below.
\begin{figure}[H]
    \centering
    \begin{tikztimingtable}[timing/slope=0, xscale=1.2]
    CLK & 12{LH} \\
    RST & H 22L 1H \\
    START & 5L 2H 17L \\
    DONE & 18L 2H 4L \\
    \end{tikztimingtable}
    \caption{Timing diagram showing one ALU controller activation cycle with a reset phase, input start pulse, and synchronization to the system clock.}
\end{figure}

The diagram illustrates the signal timing associated with a single change in input. The \texttt{CLK} signal remains periodic with a constant cycle length. This is the
result of the code mentioned in the \textit{Clock Signal Implementation} section. The \texttt{RST} (reset) signal is asserted at the beginning to initialize the system and then
deasserted after the first rising edge. It remains low for most of the operation and is reasserted at the end to reset the state for the next operation. The \texttt{START} signal 
is asserted for two clock cycles after reset is deasserted, signaling the controller to begin executing the operation based on current inputs. The \texttt{DONE} signal is asserted 
for two clock cycles once the operation is complete, indicating the result is available and the controller is ready for the next input.

All control signals (\texttt{RST}, \texttt{START}, and \texttt{DONE}) are held high for \textit{two full clock cycles} rather than one to ensure the controller registers each transition
reliably. This design choice prevents race conditions and ensures that state changes are properly latched. The effect of this timing strategy will become more evident in later sections
when the behavior of the sub-controllers is analyzed.

\section{Controller Implementation}

\subsection{Adder Controller}

\section{Subtractor Controller}

\section{Multiplier Controller}

\section{Divider Controller}

\section{Comparison Controllers}

\subsection{Waveform Analysis}

\section{Challenges and Solutions}

\section{Conclusion}

\section{Thoughts and Notes}
\begin{itemize}
    \item \textbf{How Does a Controller Work?}: The controller circuit that will control the ALU operations will need to be split into its distinct operations.
        These operations can be distinguised as the ALU\_Controller and the Sub\_Controllers. The ALU\_Controller will maintain responsibility for the overall
        flow of the ALU operations, using an opcode to determine which operation to perform. The Sub\_Controllers will be responsible for the individual
        operations themselves and return their associated results to the ALU\_Controller.
    \item \textbf{Refactoring of Current Implementations}: Because we will need to implement \textit{sequential logic} for the controller, we will need to revisit
        out implementations for our ALU modules and develop them similarly to how we developed out \textit{Division\_Core} module. The main method that is used in
        the \textit{Division\_Core} module is that it processes its operation \textit{one step at a time} as opposed to all at once (like how it is currently
        developed at the time of writing this).
    \item \textbf{Posedge Design}: The controller will need to run a clock and a reset signal to ensure operations are performed sequentially. Posedges are used
        to control the overall change in inputs of the controller. Applying a posedge requires a careful consideration for where they are placed in a system to
        both maximize efficiency and ensure that the system is functioning as intended. The general rules to follow for when to add a posedge are:
        \begin{itemize}
            \item \textbf{Posedge Between Input Change} \item \textbf{Posedge Between Control Transitions} \item \textbf{Posedge After Setting Done Signals}
        \end{itemize}
        Where a Macro is used to generalize the testing for the different controllers to be developed.
    \item \textbf{Missing Final Bit in Multiplier}: Refactoring of the current Multiplier was necessary so that it can run sequentially rather than all at once.
        However, a few bugs were encountered while trying to implement this new feature. The main issue with the final product was that the control logic was 
        performing what seemed like \textit{one extra step} in the multiplication step. More specifically, this extra step was found to be at every instance of
        in2 where its value was at its maximum. This caused an incorrect final output to be produced. What was found to be the source of the issue was that the
        FSM was \textit{conditionally updating the output registers} only when \textit{is\_equal} was true, otherwise it would skip the assignment. As a result,
        the final clock cycle would transition into the DONE state without properly updating the output registers for the final output. A resolution was developed
        that reshaped the logic in the \textit{STEP} and \textit{DONE} states, moving the final assignment out of DONE and into the STEP state while adding additional
        logic checks to ensure that the output registers were properly updated when they needed to be.
    \item \textbf{Timing Mismatch in Addition}: Refactoring the Adder Module was similarly done as the Multiplier Module. However, a bug was encountered where the output
        of the adder was shifted up the output register. This was found to be due to the timing of the output register assignment, where the output register was
        being assigned the value of the output of the adder before the adder had finished its operation. To resolve this issue, we split the function into two 
        different clock cycles, one for the addition and one for the assignment of the output register. This allowed the adder to finish its operation before the
        output register was assigned the value of the output of the adder.
    \item \textbf{Developing the ALU Flow}: To properly select which ALU operation to perform, we needed to develop a control that would handle both the individual
        operations and the the overall ALU operation over  period of time, since in reality, things take time to process. Two distictions are made between the 
        controllers however: The ALU\_Controller is responsible for the overall flow of the ALU operations, selecting the proper ALU operation to compute based on an
        opcode, and the Sub\_Controllers, whcih are responsible for the individual operations and are aptly named after the operation they are performing. THe main
        difference between these is that the Sub\_Controllers run on posedges, while the ALU\_Controller runs without a posedge. The choice was to avoid any confusion
        in the ALU\_Controller, since it is not a sequential operation.
\end{itemize}

Tip: Use $input{}$ for Modular Diagrams
If your report grows, put each diagram in a .tex snippet file and $input{tikz/alu_diagram.tex}$ 
into the main doc â€” keeps things clean and flexible.

\end{document}

