\documentclass[12pt]{article}

\usepackage{fancyhdr}   
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{graphicx}    % include graphics
\usepackage{natbib}         
\usepackage{doi}    
\usepackage{listings}
\usepackage{xcolor}
\usepackage[american]{circuitikz}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\setcitestyle{aysep={,}}

% Header information
\newcommand{\Group}{Group Uno}
\newcommand{\Mike}{Mike Orduna}
\newcommand{\Noah}{Noah Murphy}
\newcommand{\Alex}{Alex Livingston}
\newcommand{\Class}{CS 3339: Computer Architecture}
\newcommand{\ReportPart}{Part Three}
\newcommand{\School}{Ingram School of Engineering}

\title{Project Report: \ReportPart}
\author{
    \textbf{\Class} \\
    \\
    \textbf{\Group:} 
    \\
    \Mike\\
    \Noah\\
    \Alex\\
    \\
    \\
    \School
}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\hypersetup{hidelinks}  % remove colored boxes around links

\begin{document}
\maketitle
\newpage

\tableofcontents
\thispagestyle{empty}
\pagestyle{fancy}

\newpage
\setcounter{page}{1}

\section{Abstract}

\section{Background}    % Start by discussing what the previous parts of the project were built upon
This report is the third part of a project that aims to develop an ALU using Verilog. The ALU could not be as functional as it is currently without
the previous implementations of the ALU's most basic modules. Throughout the course of the project, design decisions were made to ensure that the ALU
remained modular and easy to understand. That being said, the ALU was chosen to follow a \textit{hierarchical design} approach, where the ALU is built
from smaller modules.

Development of the ALU began with implementing its most basic functions: \textit{Logic Gates}. Implementation starts with making modules for these basic
gates, which are then used to develop more complex modules down the line. In the first report discussed, the primary focus was ensuring that these logic
gates received the fed inputs correctly and produced the expected outputs. Futhermore, the development of a basic arithmetic shifter was implemented in
conjunction to the logic gates, as required by the projects first step. These files can be viewed under the \textbf{src} directory, and more specifically
refer to the files \textit{bit\_gates.v}, \textit{nbit\_gates.v}, and \textit{arithmetic\_operations.v}. Other modules made in this section include the
\textit{checks.v} and the \textit{mxnbit\_gates.v} files which offer additional functionality outside of the specifications of the project.

Afterwards, the development of the core functions of the ALU were implemented. This included the basic mathematical operations of an ALU: addition,
subtraction, multiplication, and division. Following the guidlines developed during the planning of the project, this section of the ALU is built on
many of the logic gates previously developed and make use of Verilogs \textit{generate} statements to instantiate the appropriate modules for each
operation. The modules refer to the files \textit{arithmetic\_operations.v} and the later added \textit{sequential\_alu.v} files. In earlier versions
of this part of the project, the operations for the ALU went through many different iterations and were all shared in the same file. However, after 
much judication and revisions, a separation of concerns was established and enforced between the two core functions, leading to the split of the files.

\section{Introduction}  % Here, we can lead the discussion over what this final part of the report covers
An ALU cannot strictly alone be defined by its core functions of addition, subtraction, multiplication, and division. An ALU is also defined by its
response to produce those results over a period of time. Without a form of control logic in the ALU, it performs its operations all at once, which is not
how a realistic ALU would operate on hardware. This is where the introduction of a controller is necessary and where this part of the report will focus on.
The challenge of working and developing a controller introduces a new procedure to the ALU operations already developed. A refactoring of the ALU's modules
is necessary to accommodate the introduction of a controller to the system. Despite the challenge of refactoring pre existing modules, the ALU overall benefits
from this change.

\section{Controller Design}

\subsection{Separation of Concerns}

\section{Testbench Development}

\section{Controller Implementation}

\subsection{Adder Controller}

\section{Subtractor Controller}

\section{Multiplier Controller}

\section{Divider Controller}

\section{Comparison Controllers}

\subsection{Waveform Analysis}

\section{Challenges and Solutions}

\section{Conclusion}

\section{Thoughts and Notes}
\begin{itemize}
    \item \textbf{How Does a Controller Work?}: The controller circuit that will control the ALU operations will need to be split into its distinct operations.
        These operations can be distinguised as the ALU\_Controller and the Sub\_Controllers. The ALU\_Controller will maintain responsibility for the overall
        flow of the ALU operations, using an opcode to determine which operation to perform. The Sub\_Controllers will be responsible for the individual
        operations themselves and return their associated results to the ALU\_Controller.
    \item \textbf{Refactoring of Current Implementations}: Because we will need to implement \textit{sequential logic} for the controller, we will need to revisit
        out implementations for our ALU modules and develop them similarly to how we developed out \textit{Division\_Core} module. The main method that is used in
        the \textit{Division\_Core} module is that it processes its operation \textit{one step at a time} as opposed to all at once (like how it is currently
        developed at the time of writing this).
    \item \textbf{Posedge Design}: The controller will need to run a clock and a reset signal to ensure operations are performed sequentially. Posedges are used
        to control the overall change in inputs of the controller. Applying a posedge requires a careful consideration for where they are placed in a system to
        both maximize efficiency and ensure that the system is functioning as intended. The general rules to follow for when to add a posedge are:
        \begin{itemize}
            \item \textbf{Posedge Between Input Change} \item \textbf{Posedge Between Control Transitions} \item \textbf{Posedge After Setting Done Signals}
        \end{itemize}
        Where a Macro is used to generalize the testing for the different controllers to be developed.
    \item \textbf{Missing Final Bit in Multiplier}: Refactoring of the current Multiplier was necessary so that it can run sequentially rather than all at once.
        However, a few bugs were encountered while trying to implement this new feature. The main issue with the final product was that the control logic was 
        performing what seemed like \textit{one extra step} in the multiplication step. More specifically, this extra step was found to be at every instance of
        in2 where its value was at its maximum. This caused an incorrect final output to be produced. What was found to be the source of the issue was that the
        FSM was \textit{conditionally updating the output registers} only when \textit{is\_equal} was true, otherwise it would skip the assignment. As a result,
        the final clock cycle would transition into the DONE state without properly updating the output registers for the final output. A resolution was developed
        that reshaped the logic in the \textit{STEP} and \textit{DONE} states, moving the final assignment out of DONE and into the STEP state while adding additional
        logic checks to ensure that the output registers were properly updated when they needed to be.
    \item \textbf{Timing Mismatch in Addition}: Refactoring the Adder Module was similarly done as the Multiplier Module. However, a bug was encountered where the output
        of the adder was shifted up the output register. This was found to be due to the timing of the output register assignment, where the output register was
        being assigned the value of the output of the adder before the adder had finished its operation. To resolve this issue, we split the function into two 
        different clock cycles, one for the addition and one for the assignment of the output register. This allowed the adder to finish its operation before the
        output register was assigned the value of the output of the adder.
    \item \textbf{Developing the ALU Flow}: To properly select which ALU operation to perform, we needed to develop a control that would handle both the individual
        operations and the the overall ALU operation over  period of time, since in reality, things take time to process. Two distictions are made between the 
        controllers however: The ALU\_Controller is responsible for the overall flow of the ALU operations, selecting the proper ALU operation to compute based on an
        opcode, and the Sub\_Controllers, whcih are responsible for the individual operations and are aptly named after the operation they are performing. THe main
        difference between these is that the Sub\_Controllers run on posedges, while the ALU\_Controller runs without a posedge. The choice was to avoid any confusion
        in the ALU\_Controller, since it is not a sequential operation.
\end{itemize}

Tip: Use $input{}$ for Modular Diagrams
If your report grows, put each diagram in a .tex snippet file and $input{tikz/alu_diagram.tex}$ 
into the main doc â€” keeps things clean and flexible.

\end{document}

